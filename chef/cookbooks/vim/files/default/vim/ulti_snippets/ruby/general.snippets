snippet say
say_with_time "${1:what}" do
  execute <<-SQL
    ${2:sql}
  SQL
end
endsnippet

snippet exe "short"
execute "${1:sql}"
endsnippet

snippet exe "long"
execute <<-SQL
  ${1:sql}
SQL
endsnippet

snippet "#!"
#!/usr/bin/ruby

endsnippet

# New Block
snippet =b
=begin rdoc
  ${1}
=end

endsnippet

snippet req
require "${1}"${2}
endsnippet

snippet case
case ${1:object}
when ${2:condition}
  ${3}
end
endsnippet

snippet when
when ${1:condition}
  ${2}
endsnippet

snippet def "" b
def ${1:method_name}
  ${2}
end
endsnippet

snippet if
if ${1:condition}
  ${2}
end
endsnippet

snippet ife
if ${1:condition}
  ${2}
else
  ${3}
end
endsnippet

snippet elsif
elsif ${1:condition}
  ${2}
endsnippet

snippet unless
unless ${1:condition}
  ${2}
end
endsnippet

snippet while
while ${1:condition}
  ${2}
end
endsnippet

snippet until
until ${1:condition}
  ${2}
end
endsnippet

snippet cla-
class ${1:name}
  ${2}
end
endsnippet

snippet cla "class .. < ParentClass .. initialize .. end"
class ${1:`!v substitute(Filename(), '\([a-z]\+\)_*', '\u\1', 'g')`} < ${2:ParentClass}
  def initialize(${3:args})
    ${4}
  end
end
endsnippet

snippet str
Struct.new(${1:attr_names})
endsnippet

snippet eigen "cla class << self .. end"
class << ${1:self}
  ${2}
end
endsnippet

# attr_reader
snippet r
attr_reader :${1:attr_names}
endsnippet

# attr_writer
snippet w
attr_writer :${1:attr_names}
endsnippet

# attr_accessor
snippet rw
attr_accessor :${1:attr_names}
endsnippet

# include Enumerable
snippet Enum
include Enumerable

def each(&block)
  ${1}
end
endsnippet

# include Comparable
snippet Comp
include Comparable

def <=>(other)
  ${1}
end
endsnippet

# extend Forwardable
snippet Forw-
extend Forwardable
endsnippet

snippet defs
def self.${1:class_method_name}
  ${2}
end
endsnippet

snippet defd
def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
endsnippet

snippet defds
def_delegators :${1:@del_obj}, :${2:del_methods}
endsnippet

snippet am
alias_method :${1:new_name}, :${2:old_name}
endsnippet

snippet app
if __FILE__ == $PROGRAM_NAME
  ${1}
end
endsnippet

snippet defi
def initialize(*args)
  ${1}
end
endsnippet

snippet array
Array.new(${1:10}) { |${2:i}| ${3} }
endsnippet

snippet hash
Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
endsnippet

snippet file "File.foreach() { |line| .. }"
File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
endsnippet

snippet file "File.read()"
File.read(${1:"path/to/file"})${2}
endsnippet

snippet Dir "Dir.global() { |file| .. }"
Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
endsnippet

snippet Dir "Dir['..']"
Dir[${1:"glob/**/*.rb"}]${2}
endsnippet

snippet dir
Filename.dirname(__FILE__)
endsnippet

snippet deli
delete_if { |${1:e}| ${2} }
endsnippet

snippet fil
fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
endsnippet

snippet flao
inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
endsnippet

snippet zip
zip(${1:enums}) { |${2:row}| ${3} }
endsnippet

# downto(0) { |n| .. }
snippet dow
downto(${1:0}) { |${2:n}| ${3} }
endsnippet

snippet ste
step(${1:2}) { |${2:n}| ${3} }
endsnippet

snippet tim
times { |${1:n}| ${2} }
endsnippet

snippet upt
upto(${1:1.0/0.0}) { |${2:n}| ${3} }
endsnippet

snippet ea
each { |${1:e}| ${2} }
endsnippet

snippet eai
each_index { |${1:i}| ${2} }
endsnippet

snippet eak
each_key { |${1:key}| ${2} }
endsnippet

snippet eal
each_line { |${1:line}| ${2} }
endsnippet

snippet eas-
each_slice(${1:2}) { |${2:group}| ${3} }
endsnippet

snippet eav
each_value { |${1:val}| ${2} }
endsnippet

snippet eawi
each_with_index { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet reve
reverse_each { |${1:e}| ${2} }
endsnippet

snippet inj
inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
endsnippet

snippet map
map { |${1:e}| ${2} }
endsnippet

snippet mapwi-
enum_with_index.map { |${1:e}, ${2:i}| ${3} }
endsnippet

snippet sor
sort { |a, b| ${1} }
endsnippet

snippet sorb
sort_by { |${1:e}| ${2} }
endsnippet

snippet ran
sort_by { rand }
endsnippet

snippet all
all? { |${1:e}| ${2} }
endsnippet

snippet any
any? { |${1:e}| ${2} }
endsnippet

snippet cl
classify { |${1:e}| ${2} }
endsnippet

snippet col
collect { |${1:e}| ${2} }
endsnippet

snippet det
detect { |${1:e}| ${2} }
endsnippet

snippet fet
fetch(${1:name}) { |${2:key}| ${3} }
endsnippet

snippet fin
find { |${1:e}| ${2} }
endsnippet

snippet fina
find_all { |${1:e}| ${2} }
endsnippet

snippet gre
grep(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet sub
${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
endsnippet

snippet sca
scan(${1:/pattern/}) { |${2:match}| ${3} }
endsnippet

snippet max
max { |a, b|, ${1} }
endsnippet

snippet min
min { |a, b|, ${1} }
endsnippet

snippet par
partition { |${1:e}|, ${2} }
endsnippet

snippet rej
reject { |${1:e}|, ${2} }
endsnippet

snippet sel
select { |${1:e}|, ${2} }
endsnippet

snippet lam
lambda { |${1:args}| ${2} }
endsnippet

snippet do
do |${1:variable}|
  ${2}
end
endsnippet

snippet do-
do
  ${1}
end
endsnippet

snippet :
${1:key}: ${2:"value"}${3}
endsnippet

snippet ope
open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
endsnippet

snippet patfh
File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
endsnippet

snippet unif
ARGF.each_line${1} do |${2:line}|
  ${3}
end
endsnippet

# option_parse {}
snippet optp
require "optparse"

options = {${1:default => "args"}}

ARGV.options do |opts|
  opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
endsnippet

snippet opt
opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
         "${4:Option description.}") do |${5:opt}|
  ${6}
end
endsnippet

# Benchmark.bmbm do .. end
snippet bm-
TESTS = ${1:10_000}
Benchmark.bmbm do |results|
  ${2}
end
endsnippet

snippet rep
results.report("${1:name}:") { TESTS.times { ${2} }}
endsnippet

# Marshal.dump(.., file)
snippet Md
File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
endsnippet

# Mashal.load(obj)
snippet Ml
File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
endsnippet

# deep_copy(..)
snippet deec
Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
endsnippet

snippet tra
transaction(${1:true}) { ${2} }
endsnippet

# xmlread(..)
snippet xml-
REXML::Document.new(File.read(${1:"path/to/file"}))${2}
endsnippet

# xpath(..) { .. }
snippet xpa
elements.each(${1:"//Xpath"}) do |${2:node}|
  ${3}
end
endsnippet

# class_from_name()
snippet clafn
split("::").inject(Object) { |par, const| par.const_get(const) }
endsnippet

# singleton_class()
snippet sinc
class << self; self end
endsnippet

snippet nam
namespace :${1:`!v substitute(Filename(), '\([a-z]\+\)_*', '\1', 'g')`} do
  ${2}
end
endsnippet

snippet tas
desc "${1:Task description}"
task ${2:task_name}, [${3:args}] => [:environment] do |t, args|
  args.with_defaults(${4:defaults})
  ${5}
end
endsnippet

snippet tas-
desc "${1:Task description}"
task ${2:task_name} do
  ${3}
end
endsnippet

snippet utf8
# coding: utf-8
endsnippet
